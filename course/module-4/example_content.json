[
  {
    "instruction": "Write a post presenting a list of essential ML monitoring metrics, aiming to educate followers on effective monitoring practices.",
    "content": "I compiled a list of the top 10 metrics your ML monitoring system should track.\n.\n#ğŸ ğğ©ğğ«ğšğ­ğ¢ğ¨ğ§ğšğ¥ ğ¦ğğ­ğ«ğ¢ğœğ¬\nUsed to monitor the health of your overall software system.\nâ latency\nâ throughput\nâ CPU/GPU utilization\nâ memory utilization\nâ the number of requests your model receives in the last X minutes/hours/days\nâ the number of successful requests\n#ğŸ ğŒğ‹-ğ¬ğ©ğğœğ¢ğŸğ¢ğœ ğ¦ğğ­ğ«ğ¢ğœğ¬\nUsed to monitor the performance of your ML system.\nâ accuracy (extremely useful when you have feedback or natural labels from the user: click rate, upvote, downvote, purchases, bookmarks, views, etc.)\nâ predictions (as predictions are low dimensional various statistics are easy to compute + the distribution of the prediction represents a proxy for the input distribution)\nâ features (feature validation + two-sample tests for drift detection)\nâ raw inputs (these are harder to monitor due to their scattered nature within the infrastructure)\n-----\nğŸ’¡ My goal is to make\nhashtag\n#\nml\neasy and intuitive. Follow me for daily insights about\nhashtag\n#\ndata\n,\nhashtag\n#\nml\n, and\nhashtag\n#\nmlops\n."
  },
  {
    "instruction": "Explain the benefits of using the walrus operator in Python for writing cleaner code.",
    "content": "Here is some ğ—£ğ˜†ğ˜ğ—µğ—¼ğ—» ğ˜€ğ˜†ğ—»ğ˜ğ—®ğ˜… ğ˜€ğ˜‚ğ—´ğ—®ğ—¿ that will help you ğ˜„ğ—¿ğ—¶ğ˜ğ—² ğ—°ğ—¹ğ—²ğ—®ğ—»ğ—²ğ—¿ ğ—°ğ—¼ğ—±ğ—² â†“ \n\nI am talking about the ğ˜¸ğ˜¢ğ˜­ğ˜³ğ˜¶ğ˜´ ğ˜°ğ˜±ğ˜¦ğ˜³ğ˜¢ğ˜µğ˜°ğ˜³ denoted by the `:=` symbol. \n\nIt was introduced in Python 3.8, but I rarely see it used. \n\nThus, as a \"clean code\" freak, I wanted to dedicate a post to it. \n\nğ—ªğ—µğ—®ğ˜ ğ—±ğ—¼ğ—²ğ˜€ ğ˜ğ—µğ—² ğ˜„ğ—®ğ—¹ğ—¿ğ˜‚ğ˜€ ğ—¼ğ—½ğ—²ğ—¿ğ—®ğ˜ğ—¼ğ—¿ ğ—±ğ—¼? \n\nIt's an assignment expression that allows you to assign and return a value in the same expression. \n\nğ—ªğ—µğ˜† ğ˜€ğ—µğ—¼ğ˜‚ğ—¹ğ—± ğ˜†ğ—¼ğ˜‚ ğ˜‚ğ˜€ğ—² ğ—¶ğ˜? \n\nğ˜Šğ˜°ğ˜¯ğ˜¤ğ˜ªğ˜´ğ˜¦ğ˜¯ğ˜¦ğ˜´ğ˜´: It reduces the number of lines needed for variable assignment and checking, making code more concise. \n\nğ˜™ğ˜¦ğ˜¢ğ˜¥ğ˜¢ğ˜£ğ˜ªğ˜­ğ˜ªğ˜µğ˜º: It can enhance readability by keeping related logic close, although this depends on the context and the reader's familiarity with exotic Python syntax. \n\nğ™ƒğ™šğ™§ğ™š ğ™–ğ™§ğ™š ğ™¨ğ™¤ğ™¢ğ™š ğ™šğ™­ğ™–ğ™¢ğ™¥ğ™¡ğ™šğ™¨ \n\nâ†“â†“â†“ \n\n1. Using the walrus operator, you can directly assign the result of the ğ˜­ğ˜¦ğ˜¯() function inside an if statement. \n\n2. Avoid calling the same function twice in a while loop. The benefit is less code and makes everything more readable. \n\n3. Another use case arises in list comprehensions where a value computed in a filtering condition is also needed in the expression body. Before the ğ˜¸ğ˜¢ğ˜­ğ˜³ğ˜¶ğ˜´ ğ˜°ğ˜±ğ˜¦ğ˜³ğ˜¢ğ˜µğ˜°ğ˜³, if you had to apply a function to an item from a list and filter it based on some criteria, you had to refactor it to a standard for loop. \n\n. \n\nWhen writing clean code, the detail matters. \n\nThe details make the difference between a codebase that can be read like a book or one with 10 WTFs / seconds. \n\n. \n\nWhat do you think? Does the walrus operator make the Python code more readable and concise? \n\nhashtag\n#machinelearning \nhashtag\n#mlops \nhashtag\n#datascience \n"
  }
]